---
title: "Coastal_TS.Rmd"
author: "J. Hagy"
date: "January 22, 2021"
output: pdf_document
---
# 1. Setup
```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

pkgs <- c("devtools", "randomForest", "dplyr", "rjags", "arm", "xtable","caret","ggplot2","knitr","tibble","tidyverse",
          "lmodel2")

cran_no <- pkgs[!pkgs %in% installed.packages()[,1]]
for(i in cran_no){
  install.packages(i)
}

lapply(pkgs, library, character.only = T)

source("functions/coastal_tsi_functions.R")

# make sure that select is from dplyr
# MASS package often takes over select function, this returns it to dplyr
select <- dplyr::select
```
# 2. Read all the data
```{r}

inFile <- "Raw/CoastalWQ_20200831.csv"
coastal <- read.csv(inFile, stringsAsFactors = FALSE) %>% 
  filter(SAMPYEAR==2010 | SAMPYEAR==2015) %>% 
  filter(VISNUM==1, Col_loc=="SURFACE") %>% 
  filter(!(REGION %in% c("Great Lakes","Insular"))) %>%  # remove Great Lakes and Insular Regions
  fixRegions(.) %>% 
  add2015secchi(.)

#Remove rows where any of these variables has a missing value
coastal <- coastal[complete.cases(coastal[,c("SECCHI_MEAN..m.","DIP..mgP.L.","DIN..mgN.L.","TN..mgN.L.","TP..mgP.L.","CHLA..ug.L.")]),]

write.csv(select(coastal,Latitude,Longitude),file="latlong.csv")
#https://vdatum.noaa.gov/vdatumweb/#ASCII

# Determine quantile-based Chl-a break points using only 2010 data
# Breaks_Chla_Q <- coastal %>% 
#   filter(SAMPYEAR==2010) %>% 
#   .[,"CHLA..ug.L."] %>% 
#   quantile(probs = seq(0.25, 0.75, by = 1/4),na.rm=TRUE) %>% 
#   c(0,.,Inf)
# Use pre-determined breaks, rather than values based on percentiles of data. 
Breaks_Chla_Q <- c(0,5,10,20,Inf)

# Define ordinal Chl-a class variable using quantile-based breaks
coastal <- mutate(coastal,TS_Chla_Q=cut(CHLA..ug.L., 
                                        breaks=Breaks_Chla_Q, 
                                        labels=c("Oligo", "Meso", "Eu", "Hyper")))

# What percentage of non-detects are there for each variable?
# there is 0 to 2.8% non detects.
evaluateNonDetects(coastal)

# Replace the non-detects with 2010 NCCA MDL values
#  there aren't very many non-detects, but replacing with MDL is
#  not especially appearling.  Replace with unform random variable??
coastal[coastal[,"TP..mgP.L."]==0,"TP..mgP.L."] <- 0.0012
coastal[coastal[,"DIN..mgN.L."]==0,"DIN..mgN.L."] <- 0.001
coastal[coastal[,"DIP..mgP.L."]==0,"DIP..mgP.L."] <- 0.0027

# Define lists of predictors
nutrientPredictors <- c("TN..mgN.L.","DIN..mgN.L.","TP..mgP.L.","DIP..mgP.L.","DIN.DIP..Molar.","TN.TP..Molar.","SECCHI_MEAN..m.")
regionPredictors <- c("Latitude","Longitude","REGION","SUBREGIONS","levelIII","AggEco","EMAP","BioGeo")
predictors_coastal <- c(nutrientPredictors,regionPredictors)

#save(coastal,file="coastalTSI_NCAdata_all.Rdata")

```
# 2. Extract the 2010 Data from full data
```{r include=FALSE}
# now reading all data at the same time, so just subsample it.
coastal2010 <- filter(coastal,SAMPYEAR==2010)

```
# 2a. Extract the 2015 Data from the full data  
```{r include=FALSE}
# now reading all data at the same time, so just subsample it.
coastal2015 <- filter(coastal,SAMPYEAR==2015)
```
# Compare number of observations in each subregion in 2010 and 2015
There are 22 subregions in both the 2010 and 2015 data
```{r "Compare Regions", echo=FALSE, results="asis"}

# Compare the number of level III ecoregions and observations in each ecoregion
tmp <- select(coastal,SAMPYEAR,levelIII,TS_Chla_Q) %>%
              group_by(SAMPYEAR,levelIII,TS_Chla_Q) %>%
              summarize(n=n()) %>%
              pivot_wider(names_from=c("SAMPYEAR","TS_Chla_Q"),
                          values_from="n",values_fill=0)
tmp
write.csv(tmp,file="ObservationsByEcoregionTS.csv")
# note that there aren't any observations in WALLAMETTE VALLEY in 2015.

```
# Prepare descriptive statistics and graphics for data from the two years
```{r}

#Box plots are OK, but are less informative than the scatter plots.
# ggplot(tmp,aes(x=factor(SAMPYEAR),y=CHLA..ug.L.))+
#   geom_boxplot() +
#   facet_wrap(~levelIII,ncol=3)+
#   scale_y_log10() +
#   theme(strip.text = element_text(size=8),
#         panel.grid=element_blank())

coastal %>% mutate(Year=factor(SAMPYEAR)) %>% 
ggplot(.,aes(x=TN..mgN.L.,y=CHLA..ug.L.,color=Year))+
  geom_point() +
  facet_wrap(~levelIII,ncol=3)+
  scale_y_log10() +
  scale_x_log10() +
  theme(strip.text = element_text(size=8),
        panel.grid=element_blank(),
        legend.position="top") +
  labs(y="Log Chlorophyll-a",x="Log TN (mg/L)") +
  ggtitle("Chlorophyll-a vs. TN in NARS Coastal Data",subtitle="within Level III Ecoregions")

# Calculate the mean of log-transformed predictor variables in each year
summary(coastal)

tmp <- coastal %>% 
  mutate(logSD=log(SECCHI_MEAN..m.),
         logTN=log(TN..mgN.L.),
         logTP=log(TP..mgP.L.),
         logDIN=log(DIN..mgN.L.),
         logDIP=log(DIP..mgP.L.)) %>% 
  select(SAMPYEAR,logSD,logTN,logTP,logDIN,logDIN,logDIP) %>% 
  pivot_longer(-SAMPYEAR,names_to="param") %>% 
  group_by(SAMPYEAR,param) %>% 
  summarize(mean=mean(value),sd=sd(value)) %>%
  ungroup() %>% 
  mutate(SAMPYEAR=factor(SAMPYEAR))


ggplot(tmp,aes(x=SAMPYEAR,y=mean))+
  geom_col()+
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd),width=0.25)+
  facet_wrap(~param,scales="free_y")+
  ggtitle("Distribution of WQ varables in 2010 vs. 2015")

centeringParameters <- filter(tmp,SAMPYEAR==2010) %>% select(-SAMPYEAR)
#save(centeringParameters,file="centeringParameters.Rdata")

```
# 3. Random Forest for Variable Selection - 2010 data
Fit Random Forest Models using 2010 data with various possible regionalization variables
```{r "RF2010", eval=FALSE, include=FALSE}

# Does not generate any output
# Clean up using complete cases applied to all variables

all_coastal <- coastal2010 %>% 
  select(c(predictors_coastal,"CHLA..ug.L.")) %>% 
  mutate(LogCHLA=log10(CHLA..ug.L.)) %>% 
  select(-CHLA..ug.L.)

row.names(all_coastal) <- coastal2010$SITE_ID
all_coastal <- all_coastal[complete.cases(all_coastal),]

# Model: All Variables
set.seed(42)

all_rf<-randomForest(y=all_coastal$LogCHLA,x=all_coastal[,predictors_coastal]
                     , ntree=10000, importance=TRUE, proximity=TRUE
                     , keep.forest=TRUE,keep.inbag=TRUE)

rf_subregion <- randomForest(y=all_coastal$LogCHLA,x=all_coastal[,c(nutrientPredictors,"SUBREGIONS")]
                     , ntree=10000, importance=TRUE, proximity=TRUE
                     , keep.forest=TRUE,keep.inbag=TRUE)
rf_levelIII <- randomForest(y=all_coastal$LogCHLA,x=all_coastal[,c(nutrientPredictors,"levelIII")]
                     , ntree=10000, importance=TRUE, proximity=TRUE
                     , keep.forest=TRUE,keep.inbag=TRUE)
rf_BioGeo <- randomForest(y=all_coastal$LogCHLA,x=all_coastal[,c(nutrientPredictors,"BioGeo")]
                     , ntree=10000, importance=TRUE, proximity=TRUE
                     , keep.forest=TRUE,keep.inbag=TRUE)
rf_EMAP <- randomForest(y=all_coastal$LogCHLA,x=all_coastal[,c(nutrientPredictors,"EMAP")]
                     , ntree=10000, importance=TRUE, proximity=TRUE
                     , keep.forest=TRUE,keep.inbag=TRUE)
rf_AggEco <- randomForest(y=all_coastal$LogCHLA,x=all_coastal[,c(nutrientPredictors,"AggEco")]
                     , ntree=10000, importance=TRUE, proximity=TRUE
                     , keep.forest=TRUE,keep.inbag=TRUE)
rf_LatLon <- randomForest(y=all_coastal$LogCHLA,x=all_coastal[,c(nutrientPredictors,"Latitude","Longitude")]
                     , ntree=10000, importance=TRUE, proximity=TRUE
                     , keep.forest=TRUE,keep.inbag=TRUE)

rf_allGeog <- randomForest(y=all_coastal$LogCHLA,x=all_coastal[,regionPredictors]
                     , ntree=10000, importance=TRUE, proximity=TRUE
                     , keep.forest=TRUE,keep.inbag=TRUE)

#save(all_rf,rf_subregion,rf_levelIII,rf_BioGeo,rf_EMAP,rf_AggEco,
#     rf_LatLon,rf_allGeog,file="RandomForestModels2010.Rdata")

# plot predicted vs. observed for RF model
tmp <- data.frame(observed=all_coastal$LogCHLA,predicted=all_rf$predicted)

summary(tmp)

ggplot(tmp,aes(x=observed,y=predicted))+
  geom_point()

fit <- lmodel2(predicted ~ observed, data=tmp)

```
#3a Random Forest for Variable Selection - 2015 Data
```{r "RF2015", eval=FALSE, include=FALSE}

select <- dplyr::select  # if MASS package takes over select function, this returns it to dplyr

all_coastal2015 <- coastal2015 %>% 
  select(c(predictors_coastal,"CHLA..ug.L.")) %>% 
  mutate(LogCHLA=log10(CHLA..ug.L.)) %>% 
  select(-CHLA..ug.L.)

row.names(all_coastal2015) <- coastal2015$SITE_ID
all_coastal2015 <- all_coastal2015[complete.cases(all_coastal2015),]

set.seed(62)
all_rf2015<-randomForest(y=all_coastal2015$LogCHLA,x=all_coastal2015[,predictors_coastal]
                     , ntree=10000, importance=TRUE, proximity=TRUE
                     , keep.forest=TRUE,keep.inbag=TRUE)

#save(all_rf2015,file="RandomForestModels2015.Rdata")

```
#4. 2010 Random Forest for Variable Selection - Evaluation
```{r "Evaluate Random Forest Models", eval=FALSE, include=FALSE}

load("RandomForestModels2010.Rdata")

variableLabels <- c("TN","DIN","TP","DIP","DIN:DIP","TN:TP","Secchi","Latitude","Longitude","Region","Subregions","Level III","AggEco","EMAP","BioGeo")
plt_all_RF <- plot_vImp(all_rf,"Variable Importance - 2010, All")

variableLabels <- c("TN","DIN","TP","DIP","DIN:DIP","TN:TP","Secchi","Subregions")
plt_srOnly <- plot_vImp(rf_subregion,"Variable Importance - 2010, Subregions Only")

variableLabels <- c("TN","DIN","TP","DIP","DIN:DIP","TN:TP","Secchi","Level III")
plt_levelIIIOnly <- plot_vImp(rf_levelIII,"Variable Importance - 2010, Level III Only")

variableLabels <- c("TN","DIN","TP","DIP","DIN:DIP","TN:TP","Secchi","EMAP")
plt_EMAPOnly <- plot_vImp(rf_EMAP,"Variable Importance - 2010, EMAP Only")

variableLabels <- c("TN","DIN","TP","DIP","DIN:DIP","TN:TP","Secchi","EMAP")
plt_AggEcoOnly <- plot_vImp(rf_AggEco,"Variable Importance - 2010, AggEco Only")

variableLabels <- c("TN","DIN","TP","DIP","DIN:DIP","TN:TP","Secchi","BioGeo")
plt_BioGeoOnly <- plot_vImp(rf_BioGeo,"Variable Importance - 2010, BioGeo Only")

variableLabels <- c("TN","DIN","TP","DIP","DIN:DIP","TN:TP","Secchi","Latitude","Longitude")
plt_LatLon <- plot_vImp(rf_LatLon,"Variable Importance - 2010, Lat/Lon Only")

variableLabels <- regionPredictors
plt_allGeog <- plot_vImp(rf_allGeog,"Variable Importance - 2010, Only Geography")

pdf("Figures/varImpRF_2010.pdf",width=8,height = 10,paper="letter", onefile=TRUE)
   plt_all_RF
   plt_srOnly
   plt_levelIIIOnly   
   plt_EMAPOnly
   plt_AggEcoOnly   
   plt_BioGeoOnly
   plt_LatLon
   plt_allGeog
dev.off()

pdf("Figures/varImpRF_2010_lIIIonly.pdf",width=4,height = 5,paper="letter", onefile=TRUE)
   plt_levelIIIOnly+ggtitle("")
dev.off()
   pdf("Figures/varImpRF_2010_latlonOnly.pdf",width=4,height = 5,paper="letter", onefile=TRUE)
   plt_LatLon+ggtitle("")
dev.off()


plt_all_RF
plt_srOnly
plt_levelIIIOnly   
plt_EMAPOnly
plt_AggEcoOnly   
plt_BioGeoOnly
plt_LatLon
plt_allGeog

# save(
#   plt_all_RF,
#   plt_srOnly,
#   plt_levelIIIOnly,   
#   plt_EMAPOnly,
#   plt_AggEcoOnly, 
#   plt_BioGeoOnly,
#   plt_LatLon,
#   plt_allGeog, file="Random_Forest_Plots.Rdata"
# )

```
#4a.  2015 Random Forest Variable Selection - Evaluation
```{r eval=FALSE, include=FALSE}

load("RandomForestModels2015.Rdata")

# Create variable importance plot as column graph using ggplot
variableLabels <- c("TN","DIN","TP","DIP","DIN:DIP","TN:TP","Secchi","Latitude","Longitude","Region","Subregions","Level III","AggEco","EMAP","BioGeo")
plt <- plot_vImp(all_rf2015,"Variable Importance - 2015, All")

plt

pdf("Figures/varImpRF_2015.pdf",width=8,height = 10)
   plt
dev.off()

```
#4c. Compare 2010 and 2015 Variable Importance
For 2010 and 2015, Importance is centered (mean is subtracted from each value) so that relative magnitudes can be compared directly.
```{r eval=FALSE, include=FALSE}

# combine the two importance records and center so that mean by year =0 for both years.
importance <- rbind(
  data.frame(Variables=as.character(variableLabels),
             Importance=scale(as.numeric(importance(all_rf2015,type=1)),center=TRUE,scale=FALSE),year=2010),
  data.frame(Variables=as.character(variableLabels),
             Importance=scale(as.numeric(importance(all_rf,type=1)),center=TRUE,scale=FALSE),year=2015)
             )

# calculate mean importance for ordering variables
mnImp <- importance %>% group_by(Variables) %>% summarize(mnImp=mean(Importance))
importance <- inner_join(importance,mnImp,by="Variables")

# generate column plot comparing importance.
plt <- ggplot(data=importance,aes(y=reorder(Variables,mnImp),x=Importance/100,fill=factor(year))) + 
    geom_col(orientation="y",position="dodge") +
    scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
    theme_classic() +
    labs(y="Mean Percentage Change in MSE if Removed",x="Relative Importance")+
    ggtitle("Variable Importance for Coastal TSI - 2015")
plt

pdf("Figures/varImpRF_compare2010_2015.pdf",width=8,height = 10)
   plt
dev.off()
```
#12a. Fit Bayesian POLR model to 2010 data using Ecoregions

```{r include=FALSE}

#Level III ecoregion "WILLAMETTE VALLEY" is only in the 2010 data.  Remove it and
# reset the factor levels
#coastal2010 <- filter(coastal,SAMPYEAR==2010 & levelIII != "WILLAMETTE VALLEY") %>% 
#   mutate(levelIII=factor(levelIII))

# How many Ecoregions are there?  Still called "numSubregions" so we can use the same JAGS code
numSubregions <- length(levels(coastal2010$levelIII))
#includedRegions <- levels(coastal2010$levelIII)

# Generate Model and Evaluation data sets
randomSubset(coastal2010,0.1,100)

#set up the initializations 
# Create a blank array that can be populated with random values.  Three cut-off points
cutpt.inits <- array(dim= c(3))
for (k in 1:3){
  cutpt.inits[k] <- rnorm(1)
}
cutpt.inits <- sort(cutpt.inits)
inits <- function () {list("cutpt_raw" = cutpt.inits)}

# Log-transform, then center the transformed values
# This is the wrong approach to scaling these variables.  The most obvious problem is # that we don't know what the mean and sd are, so future observations cannot be scaled # in the same way.  If TN were to be multiplied by 2 in a future year, doubling 
# both the mean and standard deviation, there would be no change at all in TN.C.
# 
# Instead we chould calculate the mean and se, and retain that.  Future data would 
# be "approximately" centered reletive to the initial data.  
# I'm not sure if the initial mean and se should be calculated on all the 2010 
# data, or just the random subset.

# use a function to calculated centered parameters using provided mean/se
# mean and se are calculated from all 2010 data 
# returns center variables to Global Environment
centerParameters(Model,centeringParameters)

#SDD.C <- as.numeric(scale(log(Model$SECCHI_MEAN..m.), center = TRUE, scale = TRUE))
#TN.C <- as.numeric(scale(log(Model$TN..mgN.L.), center = TRUE, scale = TRUE))
#TP.C <- as.numeric(scale(log(Model$TP..mgP.L.), center = TRUE, scale = TRUE))
#DIN.C <- as.numeric(scale(log(Model$DIN..mgN.L.), center = TRUE, scale = TRUE))
#DIP.C <- as.numeric(scale(log(Model$DIP..mgP.L.), center = TRUE, scale = TRUE))

# level III is passed to the data list instead of "subregions" but variable still called subregion
# so we can use the same JAGS program
DataList <-  list('TS' = factor(Model[,"TS_Chla_Q"])
                ,'SD' = SDD.C
                ,'Nitrogen' = TN.C
                ,'Phosphorus' = TP.C
                ,'DIN' = DIN.C
                ,'DIP' = DIP.C
                ,'Subregion' = factor(Model[,"levelIII"])
                ,'model_obs' = dim(Model)[1]
                ,'num_subregions' = numSubregions)

prior <- build_naive_prior(numSubregions)

# append the priors to the input list for JAGS
DataList <- append(DataList,prior)

# The parameter(s) to be monitored

parameters = c('alpha_SD', 'alpha_N', 'alpha_P', 'alpha_DIN', 'alpha_DIP', 
               'alpha_SubR','s','C')

#jags_run_parameters("test")
jags_run_parameters("final")

```
#12b. Create Bayesian graphic model object (using 2010 data, level III ecoregions)
```{r echo=TRUE}

# Start the clock!
ptm <- proc.time()
# jags.model is used to create an object representing a Bayesian graphical model, 
# specified with a BUGS-language description of the prior distribution, and a set of data.
coastal_jags_L3Eco <- jags.model('coastal_jags.R',data = DataList 
                           , inits, n.chains = nChains, n.adapt = adaptSteps)

# Stop the clock
proc.time() - ptm

#save(coastal_jags_L3Eco,file="coastal_jags_L3Eco.Rdata")

```

#13a. Sample Posterior Distribution - Bayesian POLR model for 2010 data using Ecoregions

```{r echo=TRUE}

#load("coastal_jags_L3Eco.Rdata")

# Sample the 2010 model with subregions
ptm <- proc.time()
coastal_coda_L3Eco <- sample_posterior_distribution(coastal_jags_L3Eco,parameters,iterations=10000)
proc.time() - ptm

save(coastal_coda_L3Eco,file="coastal_coda2010_L3Eco.(5-10-20).Rdata")

```
#13b. Evaluate Bayesian POLR model for 2010 data using Ecoregions
```{r, results="asis"}

#load("coastal_coda2010_L3Eco.Rdata")

# Plot
# Plotting Level III Ecoregion distributions
# There are 16 Level III ecoregions
# plot(coastal_coda_L3Eco[,1:3]) #cut points
# plot(coastal_coda_L3Eco[,4:6]) # DIN, DIP, N
# plot(coastal_coda_L3Eco[,7:9]) # P, SD, SubR1
# plot(coastal_coda_L3Eco[,10:12]) # SubR2,3,4
# plot(coastal_coda_L3Eco[,13:15]) # 5,6,7
# plot(coastal_coda_L3Eco[,16:18]) # 8,9,10
# plot(coastal_coda_L3Eco[,19:21]) # 11,12,13
# plot(coastal_coda_L3Eco[,22:24]) # 14,15,16
# plot(coastal_coda_L3Eco[,25]) # s

# Table
# Table of Parameter distribution statistics
tmp <- cbind(summary(coastal_coda_L3Eco)$quantiles, summary(coastal_coda_L3Eco)$statistics[,2])
colnames(tmp)[6] <- "sd"
xtable(tmp, floating=FALSE)

# Combine Chains
CodaOne_L3Eco <- combine_chains(coastal_coda_L3Eco,1)

# coastal_coda is a MCMC.list object  coastal_coda[[i]] is a MCMC object.
# simCodaone.Coda.Coastal is a matrix, so needs to be coerced back to a MCMC object.
MCMC.Coastal.L3Eco <- as.mcmc(CodaOne_L3Eco)

# Build a summary of the coefficients
Coeff.Summary.L3Eco <- build_coefficient_summary(CodaOne_L3Eco)
print(xtable(Coeff.Summary.L3Eco, floating=FALSE))

# Save the coefficient summary and data
save(Coeff.Summary.L3Eco,Model,Evaluation,file="Bayesian_POLR_2010.(5-10-20).Rdata")

#load("Bayesian_POLR_2010.(5-10-20).Rdata")
#load("centeringParameters.Rdata")

# Build Coefficient Matrix
Alpha <- build_coefficient_matrix(Coeff.Summary.L3Eco)
# build region matrix for Evaluation Data
regionMatrix <- build_region_matrix(Evaluation,"levelIII")
# calculate centered parameters, and TSI
centerParameters(Evaluation,centeringParameters)
X <- cbind(SDD.C, TN.C, TP.C, DIN.C, DIP.C, regionMatrix)
Alpha <- build_coefficient_matrix(Coeff.Summary.L3Eco)
TSI <- X %*% Alpha[,"mean"]
Evaluation$TSI <- TSI

# Calculate Predicted Classes and compare with observed classes
Pred.CatAll <- findPredictedClass.TSI(Evaluation,Coeff.Summary.L3Eco)
True.CatAll <- Evaluation[, "TS_Chla_Q"]
CM.TS.Multilevel <- confusionMatrix(Pred.CatAll, True.CatAll)
CM.TS.Multilevel


data.frame(
  param=rownames(Coeff.Summary.L3Eco),
  mean=Coeff.Summary.L3Eco[,"mean"],
  sd=Coeff.Summary.L3Eco[,"sd"],
  l95=Coeff.Summary.L3Eco[,"2.5%"],
  u95=Coeff.Summary.L3Eco[,"97.5%"]) %>%
  rbind(
    data.frame(
      param="Naive",
      mean=0,
      sd=31.62,
      l95=-1.96*31.62,
      u95=1.96*31.62
    )
  ) %>% 
ggplot(aes(x=param,y=mean))+
  geom_col()+
  geom_errorbar(aes(ymin=l95,ymax=u95))+
  theme_classic()+
  theme(axis.text.x = element_text(angle=90))+
  labs(x="Model Parameter",y="Parameter Value")+
  ggtitle("Bayesian POLR Model Parameters",
          subtitle="Based on 2010 fit; Errorbars show 95% confidence interval; 'Naive' = mean 0, tau=0.001")



```

# Plots of 2010 Model Results using Level III Ecoregions

```{r echo=FALSE}

labelpos <- c((-400+Coeff.Summary.L3Eco["C[1]","mean"])/2,
              (Coeff.Summary.L3Eco["C[1]","mean"]+
               Coeff.Summary.L3Eco["C[2]","mean"])/2,
              (Coeff.Summary.L3Eco["C[2]","mean"]+
               Coeff.Summary.L3Eco["C[3]","mean"])/2,
              (400+Coeff.Summary.L3Eco["C[3]","mean"])/2)

plt <- generate_graphic_model(Model,Coeff.Summary.L3Eco,"levelIII") +
  scale_x_continuous(limits=c(-400,400))+
  ggtitle("Trophic State Classification - 2010 Data using Level III Ecoregions",
              subtitle="2010 Data using Naive Prior")+
    annotate("text",x=labelpos[1],y=0.60,label="Oligotrophic")+
    annotate("text",x=labelpos[2],y=0.60,label="Mesotrophic")+
    annotate("text",x=labelpos[3],y=0.60,label="Eutrophic")+
    annotate("text",x=labelpos[4],y=0.60,label="Hypertrophic")

plt

pdf("Figures/POLR_Prob_2010L3Eco.(5-10-20).pdf", width=6, height=6, paper="letter")
  print(plt)
dev.off()

```

#14a. Process Bayesian model update using 2015 data and Level III ecoregions

```{r include=FALSE}
# Removing the missing values:
coastal2015 <- coastal2015[!is.na(coastal2015[,"SECCHI_MEAN..m."]) 
                  & !is.na(coastal2015[,"DIP..mgP.L."]) 
                  & !is.na(coastal2015[,"DIN..mgN.L."])
                  & !is.na(coastal2015[,"TN..mgN.L."])
                  & !is.na(coastal2015[,"TP..mgP.L."])
                  & !is.na(coastal2015[,"levelIII"])
                  & !is.na(coastal2015[,"CHLA..ug.L."]),]

# Replace coastal2015 with the 2010 data to run update with 2010 data
#  note:  this still did not work.
#coastal2015 <- coastal2010

#coastal2015 %>% group_by(levelIII) %>% summarize(n=n())
# Replacing the non-detects with 2010 NCCA MDL values
# These are not the MDLs for 2015.  There are very few non-detects, however.
coastal2015[coastal2015[,"TP..mgP.L."]==0,"TP..mgP.L."] <- 0.0012
coastal2015[coastal2015[,"DIN..mgN.L."]==0,"DIN..mgN.L."] <- 0.001
coastal2015[coastal2015[,"DIP..mgP.L."]==0,"DIP..mgP.L."] <- 0.0027

# Test is the number of subregions in 2015 is the same as in 2010
#if (length(unique(coastal2015$levelIII)) != numSubregions) {
#  stop("Number of regions is not the same as in 2010")
#}
# Set the levels in 2015 to be the same as 2010
#coastal2015 <- mutate(coastal2015,levelIII=factor(levelIII,levels=includedRegions))

# Generate Model and Evaluation data sets
randomSubset(coastal2015,0.1,100)

#set up the initializations 
# Thus far I haven't gotten it to work with the cutpt.inits taken from 
# Coeff.Coastal.Summary.  JDH 8/20/20
cutpt.inits <- array(dim= c(3))
for (k in 1:3){
  # initial cut point drawn from N(mean=0,sd=1)
  cutpt.inits[k] <- rnorm(1)
  #Create a blank array and populate inits with posterior cut-points from 2010 analysis
  #cutpt.inits[k] <- Coeff.Coastal.Summary[k,1]
}
cutpt.inits <- sort(cutpt.inits)
inits <- function () {list("cutpt_raw" = cutpt.inits)}

centerParameters(Model,centeringParameters)

# Log-transform, then center the transformed values
#SDD.C <- as.numeric(scale(log(Model$SECCHI_MEAN..m.), center = TRUE, scale = TRUE))
#TN.C <- as.numeric(scale(log(Model$TN..mgN.L.), center = TRUE, scale = TRUE))
#TP.C <- as.numeric(scale(log(Model$TP..mgP.L.), center = TRUE, scale = TRUE))
#DIN.C <- as.numeric(scale(log(Model$DIN..mgN.L.), center = TRUE, scale = TRUE))
#DIP.C <- as.numeric(scale(log(Model$DIP..mgP.L.), center = TRUE, scale = TRUE))

# Create list for input to JAGS
# Include the number of observations in the Model dataset
DataList <-  list('TS' = factor(Model[,"TS_Chla_Q"])
                ,'SD' = SDD.C
                ,'Nitrogen' = TN.C
                ,'Phosphorus' = TP.C
                ,'DIN' = DIN.C
                ,'DIP' = DIP.C
                ,'Subregion' = factor(Model[,"levelIII"])
                ,'model_obs' = dim(Model)[1]
                ,'num_subregions' = numSubregions)


prior <- build_informed_prior(Coeff.Summary.L3Eco,numSubregions)
#prior <- build_naive_prior(numRegions=15)

# All Naive
#useNaive <- rep(TRUE,7) 
# Informed CutPts
#useNaive <- c(FALSE,rep(TRUE,6))
# informed Cutpts and WQ parameters
#useNaive <- c(FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE)
#names(useNaive) <-  c("cutpts","sd","N","P","DIN","DIP","SubR")
#prior <- build_mixed_prior(Coeff.Summary.L3Eco,15,useNaive)

#prior <- build_less_informed_prior(Coeff.Summary.L3Eco,numRegions=15)

# append the priors to the input list for JAGS
DataList <- append(DataList,prior)

#The parameter(s) to be monitored
parameters = c('alpha_SD', 'alpha_N', 'alpha_P', 'alpha_DIN', 'alpha_DIP', 'alpha_SubR', 's', 'C')

#jags_run_parameters("test")
jags_run_parameters("final")


```
#14b. Process Bayesian model update using 2015 data and Level III ecoregions
```{r echo=TRUE}
# Start the clock!
ptm <- proc.time()
coastal_jags_update_L3Eco <- jags.model('coastal_jags.R',data = DataList 
                           , inits, n.chains = nChains, n.adapt = adaptSteps)
# Stop the clock
proc.time() - ptm

#save(coastal_jags_update_L3Eco,file="coastal_jags_update_L3Eco.Rdata")

```

#15a. Sample posterior distribution - 2015 model update using Level III ecoregions

```{r Sample2015Distribution, echo=TRUE}

#load("coastal_jags_update_L3Eco.Rdata")

# Sample the 2015 model with subregions
ptm <- proc.time()
coda_update_L3Eco <- sample_posterior_distribution(coastal_jags_update_L3Eco,parameters,iterations=10000)
proc.time() - ptm

save(coda_update_L3Eco,file="coda_update_L3Eco.(5-10-20).Rdata")

```
#15a. Evaluate 2015 model update using Level III ecoregions
```{r, results="asis"}

#load("coda_update_L3Eco.Rdata")

# Plot
# Plotting Level III Ecoregion distributions
# There are 16 Level III ecoregions
# plot(coda_update_L3Eco[,1:3]) #cut points
# plot(coda_update_L3Eco[,4:6]) # DIN, DIP, N
# plot(coda_update_L3Eco[,7:9]) # P, SD, SubR1
# plot(coda_update_L3Eco[,10:12]) # SubR2,3,4
# plot(coda_update_L3Eco[,13:15]) # 5,6,7
# plot(coda_update_L3Eco[,16:18]) # 8,9,10
# plot(coda_update_L3Eco[,19:21]) # 11,12,13
# plot(coda_update_L3Eco[,22:24]) # 14,15,16
# plot(coda_update_L3Eco[,25]) # s

# Table of Parameter distribution statistics
tmp <- cbind(summary(coda_update_L3Eco)$quantiles, summary(coda_update_L3Eco)$statistics[,2])
colnames(tmp)[6] <- "sd"
xtable(tmp, floating=FALSE)

# Combine Chains
CodaOne_update_L3Eco <- combine_chains(coda_update_L3Eco,1)

# coastal_coda is a MCMC.list object  coastal_coda[[i]] is a MCMC object.
# simCodaone.Coda.Coastal is a matrix, so needs to be coerced back to a MCMC object.
MCMC.Coastal_Update.L3Eco <- as.mcmc(CodaOne_update_L3Eco)

# Build a summary of the coefficients
Coeff.Summary.update.L3Eco <- build_coefficient_summary(CodaOne_update_L3Eco)
xtable(Coeff.Summary.update.L3Eco, floating=FALSE)

# Save the coefficient summary and data
save(Coeff.Summary.update.L3Eco,Model,Evaluation,file="Bayesian_POLR_2015update.(5-10-20).Rdata")

rbind(
data.frame(
  param=rownames(Coeff.Summary.L3Eco),
  mean=Coeff.Summary.L3Eco[,"mean"],
  sd=Coeff.Summary.L3Eco[,"sd"],
  l95=Coeff.Summary.L3Eco[,"2.5%"],
  u95=Coeff.Summary.L3Eco[,"97.5%"]) %>%
  mutate(fit="Naive")
,
data.frame(
  param=rownames(Coeff.Summary.update.L3Eco),
  mean=Coeff.Summary.update.L3Eco[,"mean"],
  sd=Coeff.Summary.update.L3Eco[,"sd"],
  l95=Coeff.Summary.update.L3Eco[,"2.5%"],
  u95=Coeff.Summary.update.L3Eco[,"97.5%"]) %>%
  mutate(fit="Update")
) %>% 
ggplot(aes(x=param,y=mean,fill=fit))+
  geom_col(position="dodge")+
  geom_errorbar(aes(ymin=l95,ymax=u95),position="dodge")+
  theme_classic()+
  theme(axis.text.x = element_text(angle=90))+
  labs(x="Model Parameter",y="Parameter Value")+
  ggtitle("Bayesian POLR Model Parameters",
          subtitle="Update using 2015 data; Errorbars show 95% confidence interval")

# Build Coefficient Matrix
Alpha <- build_coefficient_matrix(Coeff.Summary.update.L3Eco)
# build region matrix for Evaluation Data
regionMatrix <- build_region_matrix(Evaluation,"levelIII")
# calculate centered parameters, and TSI
centerParameters(Evaluation,centeringParameters)
X <- cbind(SDD.C, TN.C, TP.C, DIN.C, DIP.C, regionMatrix)
Alpha <- build_coefficient_matrix(Coeff.Summary.update.L3Eco)
TSI <- X %*% Alpha[,"mean"]
Evaluation$TSI <- TSI

# Calculate Predicted Classes and compare with observed classes
Pred.CatAll <- findPredictedClass.TSI(Evaluation,Coeff.Summary.update.L3Eco)
True.CatAll <- Evaluation[, "TS_Chla_Q"]
CM.TS.Multilevel <- confusionMatrix(Pred.CatAll, True.CatAll)
CM.TS.Multilevel

Pred.CatAll <- findPredictedClass(Evaluation,Coeff.Summary.update.L3Eco)
True.CatAll <- Evaluation[, "TS_Chla_Q"]

xtable(CM.TS.Multilevel$table)
CM.TS.Multilevel$overall["Accuracy"]
CM.TS.Multilevel$byClass[,"Balanced Accuracy"]

CM.TS.Multilevel <- confusionMatrix(Pred.CatAll, True.CatAll)
CM.TS.Multilevel

xtable(CM.TS.Multilevel$table)

CM.TS.Multilevel$overall["Accuracy"]
CM.TS.Multilevel$byClass[,"Balanced Accuracy"]


```

#16. Graph 2015 model update using Level III ecoregions

```{r echo=FALSE}

labelpos <- c((-400+Coeff.Summary.update.L3Eco["C[1]","mean"])/2,
              (Coeff.Summary.update.L3Eco["C[1]","mean"]+
               Coeff.Summary.update.L3Eco["C[2]","mean"])/2,
              (Coeff.Summary.update.L3Eco["C[2]","mean"]+
               Coeff.Summary.update.L3Eco["C[3]","mean"])/2,
              (400+Coeff.Summary.update.L3Eco["C[3]","mean"])/2)


plt <- generate_graphic_model(Model,Coeff.Summary.update.L3Eco,"levelIII")+
  scale_x_continuous(limits=c(-400,400))+
  ggtitle("Trophic State Classification - 2015 Data using Level III Ecoregions",
          subtitle="Using Informed Prior")+
    annotate("text",x=labelpos[1],y=0.65,label="Oligotrophic")+
    annotate("text",x=labelpos[2],y=0.65,label="Mesotrophic")+
    annotate("text",x=labelpos[3],y=0.65,label="Eutrophic")+
    annotate("text",x=labelpos[4],y=0.65,label="Hypertrophic")
plt

pdf("Figures/POLR_Prob_2015L3Eco.(5-10-20).pdf", width=6, height=6, paper="letter")
 print(plt)
invisible(dev.off())

```

Introduction to Stan: https://ourcodingclub.github.io/tutorials/stan-intro/

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
